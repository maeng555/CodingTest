// 인접행렬 - > 그래프에서 정점과 간선의 관계를 나타내는  bool 타입의 정사각형 행렬  0또는1로 표현 

// 정사각형 - 행과 열이 같다 
// ex a[from][to] -> a from정점에서 to정점까지 연결된 간선이 있다 ( 0 또는 1로 판단 )
// 문제를 풀때는 y축중심으로 ! (이중for문으로)

// const int V= 4;
// bool a[V][V]= {
//     {0,1,1,1},
//     {1,0,1,0},
//     {1,1,0,0},
//     {1,0,0,0},
// };

// for (int i = 0; i < V; i++)
// {
//     for (int j = 0; i < v; i++)
//     {
//        if(a[i][j]){
//          cout << i << "부터"<<j<<"까지경로가 있습니다 .\n";
//          bfs(i);
//          dfs(i);
//        }
       

//     }
    
// }

//3번 노드에서 5번 노드로 가는 단방향 경로가있고 인접행렬로 표현 -> a[3][5] =1; 
// 양방향이면? a[3][5] =1;  a[5][3] =1; 
//인접행렬 크기를 선언할때는 정점의개수에 맞게 선언 - 메모리최소화 

// 1번.
// 정점은 0번 부터 9번까지 10개의 노드가 있다. 1 - 2 / 1 - 3 / 3 - 4 라는 경로가 있다. (1번과 2번,
// 1번과 3번, 3번과 4번은 연결되어있다.) 이를 인접행렬로 표현하라.
// 2번.
// 0번부터 방문안한 노드를 찾고 해당 노드부터 방문, 연결된 노드를 이어서 방문해서 출력하는
// 재귀함수를 만들어라. 여기서 정점을 방문하고 다시 방문하지 않게 만들어야 한다.

#include <bits/stdc++.h>
using namespace std;
const int V = 10;
 bool a[V][V], visited[V]; 

 void go(int from){
    visited[from] =1;
    cout << from << "\n"; //방문 처리 
    for (int i = 0; i < V; i++)
    {
       if(visited[i]) continue;
       if(a[from][i]){
        go(i);
       }
    }
    return;
    
 }
int main(){
    a[1][2]= 1; a[2][1]=1;
    a[1][3]=1;  a[3][1]=1;
    a[3][4]=1;  a[4][3]=1;

    for (int i = 0; i < V; i++)
    {
       for (int j = 0; j < V; j++)
       {
        if(a[i][j]&& visited[i] == 0){
            go(i);
        }
       }
       
    }
    return 0;
    
}